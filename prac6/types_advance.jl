### A Pluto.jl notebook ###
# v0.20.4

using Markdown
using InteractiveUtils

# ╔═╡ b930c120-f1a6-11ef-196c-dded6ceed45c
md"""
# Практическая работа 
"""

# ╔═╡ e8520820-1a79-4089-9c43-9f378ac3d78a
md"""
## Мутабельные структурированные типы
Если составной тип объявлен с `mutable struct` вместо `struct`, то его экземпляры будут изменяемы:

"""

# ╔═╡ 6e95235b-0c28-4fff-aefc-e2869964db83
mutable struct Bar
           baz
           qux::Float64
end

# ╔═╡ c48bc4cf-5a58-4ee9-9b9e-4a140d0e633e
bar = Bar(42, 42.0)

# ╔═╡ 515b5cd3-3e6f-4337-844f-2cd539b3fb97
bar.baz = 24

# ╔═╡ c5625e48-494c-45bd-b93c-dc0e51117234
bar

# ╔═╡ 2092255c-dd2e-4063-902f-3fe3e3e7aa13
md"""
В тех случаях, когда известно, что одно или несколько полей изменяемой структуры являются неизменяемыми, можно объявить эти поля как `const`. 

"""

# ╔═╡ 12285e2f-c4e0-4308-870f-05f1c7f2a496
md"""
## Параметрические типы 
Мы уже ранее рассматривали абстрактные и структурные типы, но не работали с более высокоуровневой абстракцией - параметрическими типами. 


> Параметрические типы — это механизм в программировании, который позволяет создавать универсальные структуры данных или компоненты, способные работать с разными типами данных, сохраняя при этом безопасность типов.

Чаще всего, такие типы являются "коробками" предоставляющими обертку для однотипной работы с разными данными. Т.е. логика работы с данными не меняется вне зависимости от того, что хранится в "коробке", но создавать конкретную версию под каждый тип не рационально. Тогда, вместо этого, создается единый параметрический тип, реализующий конкретное поведение. 

Для простоты, будет воспринимать параметрические типы, как типы-коллекции. Например, массив. Работа с данными в массиве не меняется, вне зависимости от того, что там хранится, но для системы типов важно, что массив был типизирован. 

Проведем несколько проверок над параметризованным массивом:

"""

# ╔═╡ 041d4ac5-c2ac-4b98-b379-337b60ad5e46
Array{Int}

# ╔═╡ fee20e48-6cc1-40fd-b53d-668eb9e6b1f4
[1] isa Array

# ╔═╡ 4e709b6e-3120-43fa-a5a0-00c3e37a86d3
Array{Int, 2}

# ╔═╡ acb32546-06b2-45dc-a2ac-fb2a304cad3e
[1] isa Array{Int, 1}

# ╔═╡ 6cacb828-3b6d-41c1-8c2f-b23260c0a8ca
[1] isa Array{Int}

# ╔═╡ b1784bfd-b505-46b2-8ad9-afc999aec4b7
md"""
В Julia для типов, обычно, работает инвариантность, это позволяет быть уверенным, что в одном параметрическом типе не будут содержаться типы с разным поведением

> Инвариантность — это свойство параметрических типов, при котором два обобщенных типа считаются совместимыми только в том случае, если их параметры типов полностью совпадают. Другими словами, если у вас есть Generic<A> и Generic<B>, то они не связаны через наследование, даже если A и B связаны (например, A — подтип B)


"""

# ╔═╡ 08b1e3b9-2efe-42fc-b19f-d53650ec1861
[1] isa Array{Number} # Int <: Number

# ╔═╡ 54adad1e-011c-4fc3-b9e6-19fd0579619e
md"""
## Параметрические составные типы
"""

# ╔═╡ 1f329f95-1373-491b-8ba1-ba0f0250865c
struct Point{T}
	x::T
	y::T
end

# ╔═╡ eb171a2a-e81e-4d88-82c6-3df3ccc223f4
md"""
Это объявление определяет новый параметрический тип, `Point{T}`, содержащий две "координаты" типа `T`. 

`Point{Float64}` - это конкретный тип, эквивалентный типу, определенному заменой `T` в определении `Point` на `Float64`. Таким образом, это единственное объявление фактически декларирует неограниченное количество типов: `Point{Float64}`, `Point{AbstractString}`, `Point{Int64}` и т.д. Каждый из них теперь является пригодным для использования конкретным типом:
"""

# ╔═╡ cf7a81dc-f6b7-4316-b811-0bbf4ede5e7e
Point{AbstractString}

# ╔═╡ 214b8656-9d6a-414e-a729-250bc1bd4437
Point{Float64} <: Point

# ╔═╡ 7d76ff09-4e2f-4462-8fdb-b9a5b43dbe25
Point(42.0, 24.0)

# ╔═╡ db71cc77-a158-4583-8e53-6a94469a2e70
Point(42, 24)

# ╔═╡ 89e25cfd-e548-409e-80ac-8476f124b5a8
md"""
Покажем инвариантность типов
"""

# ╔═╡ 70d520e6-9ad5-416b-a7b4-6a089f35c8e7
Point{Int} <: Point{Float32}

# ╔═╡ f0219449-58a6-416b-80ef-7f3d52db8d31
Point{Int16} <: Point{Int32}

# ╔═╡ becd420c-4187-43c1-9b9f-82fe0e7bf7de
md"""
Параметрический подстановочный тип T не ограничен и является DataType. Но это не всегда оправдано, с точки зрения поведения типа. Например, не очень осмысленно было бы иметь точку координаты которой это строки. Для того чтобы избежать попадания "лишних" типов в параметры, можно ограничить диапазон сверху. 
"""

# ╔═╡ 2014e038-9dcd-490c-a8b3-6ae8bd4740df
struct Point2{T <: Real}
	x::T
	y::T
end

# ╔═╡ b06b6e25-7270-4626-a526-de75481d41cb
md"""
Теперь Julia будет следить за соблюдением ограничений параметрического типа
"""

# ╔═╡ 3660fa86-f8e4-4aa9-a77f-2682d2fff871
Point2(2, 2)

# ╔═╡ f4b0c62a-be2d-4c32-b4b4-103926e42019
Point2([1, 2], [1, 2])

# ╔═╡ ccb5a361-458d-48fc-bc07-676c7cff7d77
md"""
## Кортежи

Кортежи представляют собой абстракцию аргументов функции - без самой функции. Основными аспектами аргументов функции являются их порядок и типы. Поэтому кортеж похож на параметризованный неизменяемый тип, где каждый параметр - это тип одного поля. 
"""

# ╔═╡ 3ba4a946-f8c2-4424-acb5-e0eebe94cecb
typeof((1, 2.0))

# ╔═╡ be85fecb-6fba-4599-9d09-27d46d17449f
md"""
Кортежи имеют несколько важных свойств, как тип: 
- Типы кортежей могут иметь любое количество параметров. 
- Типы кортежей ковариантны по своим параметрам: `Tuple{Int}` является подтипом `Tuple{Any}`. Поэтому `Tuple{Any}` считается абстрактным типом, а типы кортежей являются конкретными только в том случае, если их параметры являются таковыми. 
- Кортежи не имеют имен полей; доступ к полям осуществляется только по индексу.


> Ковариантность — это свойство параметрических типов, при котором иерархия наследования параметров типа сохраняется в обобщенном типе. Если A является подтипом B, то `Generic<A>` считается подтипом `Generic<B>`. Это позволяет работать с обобщенными типами более гибко, сохраняя безопасность типов в определенных сценариях.
"""

# ╔═╡ b44ac264-21a2-4f46-bb8b-5c8dd873ae64
Tuple{Int} <: Tuple{Number}

# ╔═╡ 26fcd38c-6aa6-4ee2-a94c-c83515b1e35d
md"""
Для кортежей также возможно определить переменное число аргументов. Для этого используется механизм `Vararg`
"""

# ╔═╡ 5ca39f33-3201-49b8-8a76-d0d4421df4f2
Tuple{Int, Vararg{Int}}

# ╔═╡ 225955b2-43cd-451f-9ed6-a10ca67908f1
md"""
В таком случае определяемый тип будет содержать два элемента:
- первый: число 
- второй: с
"""
# ╔═╡ b057c024-39bb-4287-8588-9f518e89c3f5
a::Tuple{Int, Vararg{Int}} = (1, 2, 3,4,5,6)

# ╔═╡ 4e29766b-bdeb-460f-8c97-5a0a45ee6e5c
a[1]

# ╔═╡ 45788bfb-c903-4142-9ef8-e0f306263377
a[2:end]

# ╔═╡ 557cef77-2980-4436-8ed9-d212d0a4b532
md"""
### Именованные кортежи
Именованные кортежи (Named Tuples) в Julia — это расширение обычных кортежей, где каждый элемент имеет имя (метку), в дополнение к позиции. Они сочетают в себе преимущества:

- Структурированность
- Неизменяемость
- Производительность
"""

# ╔═╡ 312da33d-370f-4d79-94c0-f479ecbd3148
typeof((a=1,b="hello"))

# ╔═╡ 07a1617e-a45e-4a19-97a2-69daefba8929
NamedTuple{(:a, :b), Tuple{Int64, String}}

# ╔═╡ 3b0cc719-4413-4cc6-8e19-c03a34363aab
b = (a=1, b="hello")

# ╔═╡ 208f5ecd-34ed-41f1-b3c4-07a66889fef0
mutable struct Baz
           a::Int
           const b::Float64
end

# ╔═╡ 02f02259-7cb2-4aff-9a80-f4ed2018d5d9
baz = Baz(1, 1.5)

# ╔═╡ 0aa1c70c-542c-4e1c-8dae-f5f84293cdc0
baz.a = 2

# ╔═╡ 15701d07-df2e-4233-9dd2-8a65a0385aa0
baz.b = 2.0

# ╔═╡ 2296b3c3-71a0-4ea5-94ee-4aacc5ebb5c9
b.a

# ╔═╡ a24fe014-3089-432c-a612-5faf3306d9f7
b.b

# ╔═╡ 8699bf04-00bf-45ff-9304-0afbddcd0a04
md"""
Для удобства записи именованных кортежей можно использовать макрос, который работает с блоком кода:
"""

# ╔═╡ f5274765-2aad-4c6e-a4e6-76f4dfa03eb6
@NamedTuple begin
	x::Int
	y::AbstractString
end

# ╔═╡ 8a314731-e490-4f6e-ae35-0c18dd504a70
md"""
## Обьединения типов 

В некоторых случаях, необходимо работать с совокупностью типов, не связанных цепочками наследования. В таком случае, можно обьединять такие типы в связанные множества. 
"""

# ╔═╡ 265462e2-d1d8-4e58-a50a-c88708b3f15d
Union{Int64, Float64}

# ╔═╡ 61128786-f2cb-4960-bdfe-515140417564
1 isa Union{Int64, Float16}

# ╔═╡ c55dc69f-0a72-462e-ae66-026652da013e
Int64 <: Union{Int64, Float64}

# ╔═╡ f5008a9b-f1ae-4acc-b25f-9c92c49b2c0d
typeintersect(Union{Int, String}, Union{Int, Float32})

# ╔═╡ a1285353-eba7-4344-9d89-50b6c2861dc3
data = [1.1, missing, 3.2, missing, 5.7, 0.4]

# ╔═╡ 09671427-cd6b-4805-9e95-dc36b4af7ff0
md"""
## UnionAll типы

Более сложным сценарием является ситуация, когда нужно наложить более сложные ограничения на параметризованный тип. Например, работа с вектором. Зададим параметрический вектор:
"""

# ╔═╡ fa44ca72-570b-4f64-bbea-54a88071cfeb
Vector = Array{T, 1} where T

# ╔═╡ 16ca1016-f29a-4f59-805b-bce55e8e01ff
md"""
Теперь обьявим функцию работающую с таким вектором, но дополнительно установим ограничения на параметризованный тип: только целые числа и их наследники
"""

# ╔═╡ fc13eb78-8a76-46bc-9b06-30600b3960d3
func(a::Vector{T}) where {T<:Integer} = T

# ╔═╡ ecadf3d2-87a8-4c89-abeb-6daf9425ebc9
func([1])

# ╔═╡ 64e55295-a769-44f6-b3d0-ff14766199c4
func([0x11])

# ╔═╡ fff1e8dd-7110-4111-9c26-f9c75d1f6cb8
func([1.0])

# ╔═╡ 0cdef978-c43a-4a44-a7ad-9ee1d72a91e6
md"""
## Конструкторы

Конструкторы это функции, которые определяют, как создавать обьекты определенного типа. 

Для многих типов формирование новых объектов путем связывания значений их полей - это все, что требуется для создания экземпляров. 

Однако в некоторых случаях при создании составных объектов требуется более широкая функциональность. Иногда необходимо обеспечить соблюдение инвариантов либо путем проверки аргументов, либо путем их преобразования.

### Внешние конструкторы

Конструктор для любого типа может быть определен просто как функция
"""

# ╔═╡ d2c749f0-9522-4976-bd13-ec5136bae785
begin

	struct Blob
		bar
		baz
	end
	Blob(x) = Blob(x, x)
end

# ╔═╡ 12219803-f39f-466f-a210-4e58b9c01b1c
Blob(42)

# ╔═╡ 564d4b05-f6c2-4b71-8808-7c2e83669476
Blob(42, 42)

# ╔═╡ bcee19a8-4be7-4470-8e5c-c6a416ee9e7f
md"""
### Внутренние конструкторы
Внутренние конструкторы похожи на внешние, за исключением двух свойств:
- они декларируются внутри блока самой структуры
- они используют специальную контекстную функцию `new`
"""

# ╔═╡ 2b813601-1f5c-4b99-b084-4732adc9723b
struct OrderedPair
           x::Real
           y::Real
           OrderedPair(x,y) = x > y ? error("out of order") : new(x,y)
end

# ╔═╡ ac9525fe-3da7-4ab5-872e-bc7367ef7a0a
OrderedPair(1, 2)

# ╔═╡ 12741fae-e6fe-4311-9510-9b8d20ada7b0
OrderedPair(2,1)

# ╔═╡ 3b30e417-e50a-445a-a2c9-1d4f44b92e79
md"""
# Задания
"""

# ╔═╡ 3e1bd786-433a-4585-9246-0e2f49d36e14
md"""
## Задание 1
Определите параметризированный тип `Point{T<}` с полями `x` и `y` типа `T`. Реализуйте метод `+(p1::Point, p2::Point)` для сложения двух точек (покомпонентное суммирование). Реализуйте функцию `scale(p::Point, factor)` для умножения координат точки на число `factor`. 
"""

# ╔═╡ aa0ca475-6296-47d1-aff3-1521842339f7
md"""
## Задание 2
Определите абстрактный тип `Account`. 
Создайте два подтипа:   
+ `SavingsAccount` – с полями `balance` (баланс) и `interest_rate` (процентная ставка).

+ `CheckingAccount` – с полем `balance` и, например, `fee` (комиссия за операцию).


Реализуйте функции `deposit(account, amount)` и `withdraw(account, amount)` для обоих типов. Для `SavingsAccount` дополнительно реализуйте функцию `apply_interest(account)`, которая прибавляет к балансу начисленные проценты.
"""

# ╔═╡ 98ac7fa4-9370-44c1-b2dc-224b17315b6d
md"""
## Задание 3
Определите параметризованный тип `Stack{T}`, который содержит внутреннее представление (например, массив) для хранения значений.

Реализуйте функции `push!(stack::Stack, value)` для добавления элемента и `pop!(stack::Stack)` для удаления последнего элемента. Также можно добавить функцию `top(stack::Stack)` для получения верхнего элемента без его удаления.
"""

# ╔═╡ 55fe3efc-5878-4de7-85b1-8cd2caf53a2d
md"""

## Задание 4
Определите параметризованный тип `Polynomial{T<:Int}`, который хранит коэффициенты многочлена в виде вектора (коэффициент при степени i хранится в элементе с индексом i+1).

Перегрузите операторы сложения (+) и вычитания (-) для операций между многочленами (учтите, что у многочленов может быть разная степень).

Реализуйте алгоритм перемножения многочленов, определив оператор *
"""

# ╔═╡ 95248f3d-6fa3-44f2-864d-33c2c7416faf
md"""
## Задание 5
Реализовать обобщённую (параметризованную) функцию, которая принимает коллекцию элементов произвольного типа и возвращает словарь, где ключом является тип элемента, а значением – количество элементов данного типа.
"""


# ╔═╡ 06839df2-3dc4-4db4-a7df-0a7a25a68f6d
md"""
## Задание 6
Создайте параметрическую структуру `GenericContainer{T}` с полем `value`, где хранятся данные произвольного типа `T`. 

Реализуйте функцию `describe`, которая возвращает строку с описанием содержимого контейнера. Функция должна иметь разные реализации для числовых типов, строк и других типов.
"""

# ╔═╡ Cell order:
# ╠═b930c120-f1a6-11ef-196c-dded6ceed45c
# ╠═e8520820-1a79-4089-9c43-9f378ac3d78a
# ╠═6e95235b-0c28-4fff-aefc-e2869964db83
# ╠═c48bc4cf-5a58-4ee9-9b9e-4a140d0e633e
# ╠═515b5cd3-3e6f-4337-844f-2cd539b3fb97
# ╠═c5625e48-494c-45bd-b93c-dc0e51117234
# ╠═2092255c-dd2e-4063-902f-3fe3e3e7aa13
# ╠═208f5ecd-34ed-41f1-b3c4-07a66889fef0
# ╠═02f02259-7cb2-4aff-9a80-f4ed2018d5d9
# ╠═0aa1c70c-542c-4e1c-8dae-f5f84293cdc0
# ╠═15701d07-df2e-4233-9dd2-8a65a0385aa0
# ╠═12285e2f-c4e0-4308-870f-05f1c7f2a496
# ╠═041d4ac5-c2ac-4b98-b379-337b60ad5e46
# ╠═fee20e48-6cc1-40fd-b53d-668eb9e6b1f4
# ╠═4e709b6e-3120-43fa-a5a0-00c3e37a86d3
# ╠═acb32546-06b2-45dc-a2ac-fb2a304cad3e
# ╠═6cacb828-3b6d-41c1-8c2f-b23260c0a8ca
# ╠═b1784bfd-b505-46b2-8ad9-afc999aec4b7
# ╠═08b1e3b9-2efe-42fc-b19f-d53650ec1861
# ╠═54adad1e-011c-4fc3-b9e6-19fd0579619e
# ╠═1f329f95-1373-491b-8ba1-ba0f0250865c
# ╠═eb171a2a-e81e-4d88-82c6-3df3ccc223f4
# ╠═cf7a81dc-f6b7-4316-b811-0bbf4ede5e7e
# ╠═214b8656-9d6a-414e-a729-250bc1bd4437
# ╠═7d76ff09-4e2f-4462-8fdb-b9a5b43dbe25
# ╠═db71cc77-a158-4583-8e53-6a94469a2e70
# ╠═89e25cfd-e548-409e-80ac-8476f124b5a8
# ╠═70d520e6-9ad5-416b-a7b4-6a089f35c8e7
# ╠═f0219449-58a6-416b-80ef-7f3d52db8d31
# ╠═becd420c-4187-43c1-9b9f-82fe0e7bf7de
# ╠═2014e038-9dcd-490c-a8b3-6ae8bd4740df
# ╠═b06b6e25-7270-4626-a526-de75481d41cb
# ╠═3660fa86-f8e4-4aa9-a77f-2682d2fff871
# ╠═f4b0c62a-be2d-4c32-b4b4-103926e42019
# ╠═ccb5a361-458d-48fc-bc07-676c7cff7d77
# ╠═3ba4a946-f8c2-4424-acb5-e0eebe94cecb
# ╠═be85fecb-6fba-4599-9d09-27d46d17449f
# ╠═b44ac264-21a2-4f46-bb8b-5c8dd873ae64
# ╠═26fcd38c-6aa6-4ee2-a94c-c83515b1e35d
# ╠═5ca39f33-3201-49b8-8a76-d0d4421df4f2
# ╠═225955b2-43cd-451f-9ed6-a10ca67908f1
# ╠═b057c024-39bb-4287-8588-9f518e89c3f5
# ╠═4e29766b-bdeb-460f-8c97-5a0a45ee6e5c
# ╠═45788bfb-c903-4142-9ef8-e0f306263377
# ╠═557cef77-2980-4436-8ed9-d212d0a4b532
# ╠═312da33d-370f-4d79-94c0-f479ecbd3148
# ╠═07a1617e-a45e-4a19-97a2-69daefba8929
# ╠═3b0cc719-4413-4cc6-8e19-c03a34363aab
# ╠═2296b3c3-71a0-4ea5-94ee-4aacc5ebb5c9
# ╠═a24fe014-3089-432c-a612-5faf3306d9f7
# ╠═8699bf04-00bf-45ff-9304-0afbddcd0a04
# ╠═f5274765-2aad-4c6e-a4e6-76f4dfa03eb6
# ╠═8a314731-e490-4f6e-ae35-0c18dd504a70
# ╠═265462e2-d1d8-4e58-a50a-c88708b3f15d
# ╠═61128786-f2cb-4960-bdfe-515140417564
# ╠═c55dc69f-0a72-462e-ae66-026652da013e
# ╠═f5008a9b-f1ae-4acc-b25f-9c92c49b2c0d
# ╠═a1285353-eba7-4344-9d89-50b6c2861dc3
# ╠═09671427-cd6b-4805-9e95-dc36b4af7ff0
# ╠═fa44ca72-570b-4f64-bbea-54a88071cfeb
# ╠═16ca1016-f29a-4f59-805b-bce55e8e01ff
# ╠═fc13eb78-8a76-46bc-9b06-30600b3960d3
# ╠═ecadf3d2-87a8-4c89-abeb-6daf9425ebc9
# ╠═64e55295-a769-44f6-b3d0-ff14766199c4
# ╠═fff1e8dd-7110-4111-9c26-f9c75d1f6cb8
# ╠═0cdef978-c43a-4a44-a7ad-9ee1d72a91e6
# ╠═d2c749f0-9522-4976-bd13-ec5136bae785
# ╠═12219803-f39f-466f-a210-4e58b9c01b1c
# ╠═564d4b05-f6c2-4b71-8808-7c2e83669476
# ╠═bcee19a8-4be7-4470-8e5c-c6a416ee9e7f
# ╠═2b813601-1f5c-4b99-b084-4732adc9723b
# ╠═ac9525fe-3da7-4ab5-872e-bc7367ef7a0a
# ╠═12741fae-e6fe-4311-9510-9b8d20ada7b0
# ╠═3b30e417-e50a-445a-a2c9-1d4f44b92e79
# ╠═3e1bd786-433a-4585-9246-0e2f49d36e14
# ╠═aa0ca475-6296-47d1-aff3-1521842339f7
# ╠═98ac7fa4-9370-44c1-b2dc-224b17315b6d
# ╠═55fe3efc-5878-4de7-85b1-8cd2caf53a2d
# ╠═95248f3d-6fa3-44f2-864d-33c2c7416faf
# ╠═06839df2-3dc4-4db4-a7df-0a7a25a68f6d
