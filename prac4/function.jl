### A Pluto.jl notebook ###
# v0.20.4

using Markdown
using InteractiveUtils

# ╔═╡ 660bcc60-e60c-11ef-19a4-eb97679b175f
md"""

# Практическая работа 

Julia предрасположена к процедурному программированию с элементами функционального, поэтому основным методом выражения поведения в программе являются функции. 

Существует несколько способов инициализировать функцию. 

Основной, это использовать семантику именованной функции

"""

# ╔═╡ 58719a60-7c57-44f5-b734-40ec762f918e
function say42(question)
	return "Ответ на вопрос $question: 42!"
end

# ╔═╡ 488a5cfc-1a4e-4a9f-a0bb-420ba5fab2aa
md"""
Теперь вызов функции доступен по ее имени
"""

# ╔═╡ aa90f8e1-3e0d-4e93-84d0-d1a3e82474a9
say42("Вселенной и всего такого")

# ╔═╡ ccb3e51f-b891-4004-bb27-6600a117d487
md"""
Существует второй способ инициализации функции - строчный, схожий с математической нотацией
"""

# ╔═╡ 1fcd10a7-49f6-4323-9008-18f50716d7d0
say42again(question) = println("Повторяю. $(say42(question))")

# ╔═╡ 4a6f229f-0a9d-4144-90ea-6edc4aeffc5d
say42again("Вселенной и всего такого")

# ╔═╡ 11cc8444-fbdd-43af-b2f9-c52e9f06b5bd
md"""
И еще один вариант для инициализации анонимной функции. 
> Анонимная функция в программировании — это функция, определенная без присвоения ей идентификационного имени. Такие функции часто используются для создания компактных блоков кода, которые можно передать как аргументы в другие функции, используемые для кратковременных операций, таких как обработка элементов коллекций, событий или выполнение обратных вызовов (callbacks).
"""

# ╔═╡ d3961b59-c0ac-402c-b14c-19efaee05b03
f1 = x -> x ^2

# ╔═╡ 324112a0-37c2-4045-9416-7e3736a21729
f1(2)

# ╔═╡ 52c2923c-20e0-49c6-b25f-854723df560b
md"""

### Типизация функций 
Julia не стремится заставить программиста указывать типы данных, поэтому вынуждена использовать утиную типизацию для динамических нетипизированных данных. 

> Утиная типизация (Duck typing) — это метод в программировании, при котором типы не выбираются строго на основании их объявления. Вместо этого объект считается принадлежащим к определенному типу в зависимости от наличия у него определенных методов и свойств, независимо от формального наследования. Принцип утиной типизации можно описать фразой: «Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, утка».

Это означает, что если Julia сможет сопоставить признаки данных и обьявленные типы, то будет вызвана реализация поведения, связанная с сопоставленным типом, вне зависимости от логики работы алгоритма. 

Например, функция отвечающая на вопрос `say42` нетипизированна, но исходя из логики алгоритма, ожидается строковый аргумент. Но функция сработает, если мы передадим и число
"""

# ╔═╡ 74699804-7aab-412b-b996-be63821dc7c8
say42(42)

# ╔═╡ 4bbca540-25ef-4e70-8d27-e238adbd5d3a
md"""
Это происходит, потому что и у чисел и у строк есть поведение, которое позволяет их печатать. 

Рассмотрим другой пример
"""

# ╔═╡ 41e1a284-e8ba-446b-bf68-08d6118666a6
f1(rand(42, 42))

# ╔═╡ 827423e2-bfaa-43b0-a439-73f98f6c9c32
md"""
Поскольку для матриц так же реализовано поведение возведения в степень, то функция работает корректно
"""

# ╔═╡ 66decfef-afd1-4307-8796-4354b889f91e
md"""
### Мутирующие и не мутирующие функции

По соглашению с разработчиками языка Julia, функции оканчивающиеся на `!` являются мутирующими, а те, которые не имеют в имени восклицательного знака -- не мутирующими. Это не значит, что это соблюдается в автоматическом режиме, поэтому стоит относится внимательнее к определению функции (читайте документацию). 

Для примера рассмотрим разницу между мутирующие функцией и не мутирующей функцией.
"""

# ╔═╡ 9ac3754f-6882-470c-98f6-074e38cef394
data = [3, 5, 1]

# ╔═╡ d130f338-442d-4ee1-b4bb-4a721ece28d8
sort(data)

# ╔═╡ f9666a97-52e6-4885-8f06-766ab3703a36
md"""
`sort` возвращает отсортированную последовательность. При этом оригинальные данные остаются без изменений
"""

# ╔═╡ 48845037-2a80-42d6-9cca-c6efa4a2128a
data

# ╔═╡ 17c616f7-4a78-4a0a-87d4-0c0d2a6b63a6
md"""
Но если вызвать `sort!`, то `data` изменится
"""

# ╔═╡ cac4b245-15a3-41c9-9250-9183171d09a4
sort!(data)

# ╔═╡ e82bdf36-a50b-4119-87f9-d49318ff5f83
data

# ╔═╡ 4d96975f-9ee8-4e10-b835-07478627ed52
md"""
### Некоторые функции высшего порядка

> Функции высшего порядка — это функции, которые могут принимать другие функции в качестве аргументов и/или возвращать их как результат своей работы. Этот подход используется для создания более абстрактных уровней программирования, позволяет упростить композицию функций, повысить модульность кода и ускорить разработку за счет повторного использования готовых решений.


`map` - одна из классических функций высшего порядка, реализацию которой можно встретить в других языках. Эта функция принимает два аргумента: другую функцию и последовательность. `map` применяет функцию к членам последовательности. 

"""

# ╔═╡ 47418425-720b-4e91-bd23-7509dfd7a36b
map(f1, [1, 2, 3, 4])

# ╔═╡ 2aeee3f3-be8b-445e-a8e2-ad7ee22181fe
md"""
Для сокращения шаблонного кода, предлагается использовать анонимные фукнции в качестве аргументов, если это не вредит читаемости
"""

# ╔═╡ 7021e7b3-4ffd-4f87-aca2-12a43ad5c996
map(x -> x % 2, [1, 2, 3, 4, 5, 6])

# ╔═╡ 7bb30f05-76a3-4e00-a692-15fa8fac3897
md"""
Еще одна классическая функция высшего порядка -- `reduce`. Эта функция также принимает два аргумента: другую функцию и последовательность. `reduce` осуществляет операцию свертки, применяя функцию к членам последовательности и аккамулируя результат. 
"""

# ╔═╡ 960c1381-2947-4591-aec4-601c8152bb45
reduce(max, [1, 3, 10, 7, 3, 6])

# ╔═╡ d2265f96-f9d2-416f-8d1a-e5616002d4e4
md"""
`broadcast` -- функция высшего порядка, схожая с `map`. Эта функция используется тогда, когда оригинальная последовательность может не поддерживать поэлементное вычисление. Например, вектор не поддерживает возведение компонент в степень, поэтому, если мы вызовем  `f1` на векторе, то получим ошибку
"""

# ╔═╡ e8dfa0d0-52c6-4c47-be5b-a7a94b2aeafc
f1([1, 3 ,4])

# ╔═╡ be7b5419-ffe0-4825-b409-2e843b16d7ff
md"""
Для того чтобы это избежать, используется `broadcast`, которая принудительно применяет функцию поэлементно к членам последовательности
"""

# ╔═╡ a053b153-ab50-4b94-a352-eaf2c3e3747d
broadcast(f1, [1, 3, 4])

# ╔═╡ 2a7653e7-4112-41a1-9eba-36cd6ee5e0e4
md"""
Для удобства записи вызов `broadcast` можно заменить синтаксическим сахаром в виде точечной записи. 

> Синтаксический сахар в программировании — это особенности синтаксиса языка, предназначенные для упрощения записи кода, делая его более лаконичным и легким для восприятия, но не добавляющие новые функции к языку. Примеры синтаксического сахара включают различные краткие формы записи условных операций, циклов и других конструкций. Эти особенности улучшают читаемость и упрощают написание кода, но транслятор или компилятор сводит их к более простым базовым конструкциям перед выполнением.

Например, можно вызвать `f1` для вектора не записывая `broadcast` в явном виде
"""

# ╔═╡ 87af4dcd-70b3-469e-9867-03969157b46c
f1.([1, 3, 4])

# ╔═╡ 491e820a-0421-4e5b-ad67-8892c13ea29c
md"""
# Задания

## Задание 1
Реализуйте функцию `add_one`, которая принимает один аргумент, прибавляет к нему единицу и возвращает его. 
"""

# ╔═╡ 86203b41-3f88-42f1-81b8-fa4207343c4b
md"""
## Задание 2 
Примените `add_one` на матрицу из чисел в диапазоне от 1 до 30 при помощи точечной записи. 
"""

# ╔═╡ 2ca452d6-736d-45be-a3d5-1d33b6591be5
md"""
## Задание 3
Напишите функцию `compose(f, g)`, которая возвращает новую функцию, описывающую композицию двух функций `f` и `g`. Т.е. `(compose(f, g))(x)` должно быть эквивалентно `f(g(x))`.
"""

# ╔═╡ c2663c1f-7299-402e-af2d-9403c163b2ba
md"""
## Задание 4
Реализуйте функцию `filter_array`, которая принимает предикативную функцию и массив, а возвращает новый массив с элементами, для которых предикативная функция вернула `true`
```julia
# Пример работы
function is_odd(x)
    return x % 2 != 0
end

filtered = filter_array(is_odd, [1, 2, 3, 4, 5])
println(filtered)  # Выведет [1, 3, 5]
```
"""

# ╔═╡ 986d8dae-177b-4ed0-a220-8a47581ba409
md"""
## Задание 5
Реализуйте функцию `make_threshold_function(threshold)`, которая создает и возвращает функцию, которая проверяет, превышает ли число заданный порог. Если число больше или равно порогу, функция должна возвращать `true`, иначе — `false`
```julia
is_over_10 = make_threshold_function(10)
println(is_over_10(9))  # Выводит false
println(is_over_10(10))  # Выводит true
println(is_over_10(11))  # Выводит true
```
"""

# ╔═╡ e5f2c7ab-7628-404c-b559-69db8258d2e1
md"""
## Задание 6 
Создайте функцию `generate_math_function(op, y)`, которая принимает строку `op` (оператор: "+", "-", "*", "/") и число `y`, возвращая новую функцию, которая применяет данную операцию и число к аргументу.
```julia
subtract_five = generate_math_function("-", 5)
println(subtract_five(10))  # Выведет 5, так как 10 - 5 = 5

multiply_by_three = generate_math_function("*", 3)
println(multiply_by_three(6))  # Выведет 18, так как 6 * 3 = 18
```
"""

# ╔═╡ fb17b457-1ab8-4b6a-97e0-5387057facac
md"""
## Задание 7
Напишите функцию `transform_strings`, которая принимает массив строк и функцию преобразования. Функция должна возвращать новый массив, где каждая строка будет изменена согласно переданной функции преобразования.
```julia
uppercase_transform = s -> uppercase(s)
result = transform_strings(["hello", "world"], uppercase_transform)
println(result)  # Выведет ["HELLO", "WORLD"]
```
"""

# ╔═╡ a54305b9-db45-4e53-bb7c-a2f78491f62f
md"""

## Задание 8
Создайте функцию `apply_to_arrays`, которая принимает два массива и функцию, применяющуюся к элементам обоих массивов (например, функцию суммирования). Верните результат в виде нового массива.
```julia
add_elements = (x, y) -> x + y
result = apply_to_arrays([1, 2, 3], [4, 5, 6], add_elements)
println(result)  # Выведет [5, 7, 9]
```
"""

# ╔═╡ Cell order:
# ╠═660bcc60-e60c-11ef-19a4-eb97679b175f
# ╠═58719a60-7c57-44f5-b734-40ec762f918e
# ╠═488a5cfc-1a4e-4a9f-a0bb-420ba5fab2aa
# ╠═aa90f8e1-3e0d-4e93-84d0-d1a3e82474a9
# ╠═ccb3e51f-b891-4004-bb27-6600a117d487
# ╠═1fcd10a7-49f6-4323-9008-18f50716d7d0
# ╠═4a6f229f-0a9d-4144-90ea-6edc4aeffc5d
# ╠═11cc8444-fbdd-43af-b2f9-c52e9f06b5bd
# ╠═d3961b59-c0ac-402c-b14c-19efaee05b03
# ╠═324112a0-37c2-4045-9416-7e3736a21729
# ╠═52c2923c-20e0-49c6-b25f-854723df560b
# ╠═74699804-7aab-412b-b996-be63821dc7c8
# ╠═4bbca540-25ef-4e70-8d27-e238adbd5d3a
# ╠═41e1a284-e8ba-446b-bf68-08d6118666a6
# ╠═827423e2-bfaa-43b0-a439-73f98f6c9c32
# ╠═66decfef-afd1-4307-8796-4354b889f91e
# ╠═9ac3754f-6882-470c-98f6-074e38cef394
# ╠═d130f338-442d-4ee1-b4bb-4a721ece28d8
# ╠═f9666a97-52e6-4885-8f06-766ab3703a36
# ╠═48845037-2a80-42d6-9cca-c6efa4a2128a
# ╠═17c616f7-4a78-4a0a-87d4-0c0d2a6b63a6
# ╠═cac4b245-15a3-41c9-9250-9183171d09a4
# ╠═e82bdf36-a50b-4119-87f9-d49318ff5f83
# ╠═4d96975f-9ee8-4e10-b835-07478627ed52
# ╠═47418425-720b-4e91-bd23-7509dfd7a36b
# ╠═2aeee3f3-be8b-445e-a8e2-ad7ee22181fe
# ╠═7021e7b3-4ffd-4f87-aca2-12a43ad5c996
# ╠═7bb30f05-76a3-4e00-a692-15fa8fac3897
# ╠═960c1381-2947-4591-aec4-601c8152bb45
# ╠═d2265f96-f9d2-416f-8d1a-e5616002d4e4
# ╠═e8dfa0d0-52c6-4c47-be5b-a7a94b2aeafc
# ╠═be7b5419-ffe0-4825-b409-2e843b16d7ff
# ╠═a053b153-ab50-4b94-a352-eaf2c3e3747d
# ╠═2a7653e7-4112-41a1-9eba-36cd6ee5e0e4
# ╠═87af4dcd-70b3-469e-9867-03969157b46c
# ╠═491e820a-0421-4e5b-ad67-8892c13ea29c
# ╠═86203b41-3f88-42f1-81b8-fa4207343c4b
# ╠═2ca452d6-736d-45be-a3d5-1d33b6591be5
# ╠═c2663c1f-7299-402e-af2d-9403c163b2ba
# ╠═986d8dae-177b-4ed0-a220-8a47581ba409
# ╠═e5f2c7ab-7628-404c-b559-69db8258d2e1
# ╠═fb17b457-1ab8-4b6a-97e0-5387057facac
# ╠═a54305b9-db45-4e53-bb7c-a2f78491f62f
